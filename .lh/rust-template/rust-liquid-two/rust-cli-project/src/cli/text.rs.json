{
    "sourceFile": "rust-template/rust-liquid-two/rust-cli-project/src/cli/text.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 17,
            "patches": [
                {
                    "date": 1718697204612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1718697624414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,4 @@\n use crate::{\n-    get_content,get_reader,\n+    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n+    CmdExector,\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718697732017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,7 @@\n use crate::{\n     get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n     CmdExector,\n-}\n\\ No newline at end of file\n+}\n+\n+use super::{verify_file,verify_path};\n+use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718700891601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,5 +3,25 @@\n     CmdExector,\n }\n \n use super::{verify_file,verify_path};\n-use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n\\ No newline at end of file\n+use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n+use clap::Parser;\n+use enum_dispatch::enum_dispatch;\n+use std::{fmt,path::PathBuf,str::FromStr};\n+use tokio::fs;\n+\n+#[derive(Debug,Parser)]\n+#[enum_dispatch(CmdExector)]\n+\n+pub enum TextSubCommand {\n+\n+    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n+    Sign(TextSignOpts),\n+\n+    #[command(about =\"Verify a signature with a public/session key\")]\n+    Verify(TextVerifyOpts),\n+\n+    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n+    Generate(KeyGenerateOpts),\n+}\n+\n"
                },
                {
                    "date": 1718701209894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,4 +24,36 @@\n     #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n     Generate(KeyGenerateOpts),\n }\n \n+\n+#[derive(Debug,Parser)]\n+pub struct TextSignOpts {\n+\n+\n+    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser = verify_file)]\n+    pub key:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextVerifyOpts {\n+\n+\n+    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser=verify_file)]\n+    pub key:String,\n+\n+    #[arg(long)]\n+    pub sig:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701343604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,5 +55,16 @@\n     pub sig:String,\n \n     #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n     pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct KeyGenerateOpts {\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+\n+    #[arg(short,long,value_parser=verify_path)]\n+    pub output_path:PathBuf,\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701368631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+use crate::{\n+    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n+    CmdExector,\n+}\n+\n+use super::{verify_file,verify_path};\n+use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n+use clap::Parser;\n+use enum_dispatch::enum_dispatch;\n+use std::{fmt,path::PathBuf,str::FromStr};\n+use tokio::fs;\n+\n+#[derive(Debug,Parser)]\n+#[enum_dispatch(CmdExector)]\n+\n+pub enum TextSubCommand {\n+\n+    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n+    Sign(TextSignOpts),\n+\n+    #[command(about =\"Verify a signature with a public/session key\")]\n+    Verify(TextVerifyOpts),\n+\n+    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n+    Generate(KeyGenerateOpts),\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextSignOpts {\n+\n+\n+    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser = verify_file)]\n+    pub key:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextVerifyOpts {\n+\n+\n+    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser=verify_file)]\n+    pub key:String,\n+\n+    #[arg(long)]\n+    pub sig:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct KeyGenerateOpts {\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+\n+    #[arg(short,long,value_parser=verify_path)]\n+    pub output_path:PathBuf,\n+}\n+\n+#[derive(Debug,Clone,Copy)]\n+pub enum TextSignFormat {\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701444428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,75 +71,12 @@\n \n #[derive(Debug,Clone,Copy)]\n pub enum TextSignFormat {\n \n+        Blake3,\n+        Ed25519,\n }\n-use crate::{\n-    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n-    CmdExector,\n-}\n \n-use super::{verify_file,verify_path};\n-use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n-use clap::Parser;\n-use enum_dispatch::enum_dispatch;\n-use std::{fmt,path::PathBuf,str::FromStr};\n-use tokio::fs;\n \n-#[derive(Debug,Parser)]\n-#[enum_dispatch(CmdExector)]\n-\n-pub enum TextSubCommand {\n-\n-    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n-    Sign(TextSignOpts),\n-\n-    #[command(about =\"Verify a signature with a public/session key\")]\n-    Verify(TextVerifyOpts),\n-\n-    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n-    Generate(KeyGenerateOpts),\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct TextSignOpts {\n-\n-\n-    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n-    pub input:String,\n-\n-    #[arg(short,long,value_parser = verify_file)]\n-    pub key:String,\n-\n-    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct TextVerifyOpts {\n-\n-\n-    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n-    pub input:String,\n-\n-    #[arg(short,long,value_parser=verify_file)]\n-    pub key:String,\n-\n-    #[arg(long)]\n-    pub sig:String,\n-\n-    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct KeyGenerateOpts {\n-\n-    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-\n-    #[arg(short,long,value_parser=verify_path)]\n-    pub output_path:PathBuf,\n+fn parse_text_sign_format(format:&str) -> Result<TextSignFormat,anyhow::Error>{\n+    format.parse();\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701560986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,5 +78,19 @@\n \n \n fn parse_text_sign_format(format:&str) -> Result<TextSignFormat,anyhow::Error>{\n     format.parse();\n+}\n+\n+\n+impl FromStr for TextSignFormat {\n+\n+    type Err = anyhow::Error;\n+\n+    fn from_str(s:&str) -> Result<Self,Self::Err>{\n+        match s {\n+             \"blake3\"=> Ok(TextSignFormat::Blake3) ,\n+             \"ed25519\"=> Ok(TextSignFormat::Ed25519) ,\n+            _ => Err(anyhow::anyhow!(\"Invalid format\")),\n+        }\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701744026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,5 +92,23 @@\n              \"ed25519\"=> Ok(TextSignFormat::Ed25519) ,\n             _ => Err(anyhow::anyhow!(\"Invalid format\")),\n         }\n     }\n+}\n+\n+impl From<TextSignFormat> for &'static str {\n+    fn from(format:TextSignFormat) -> Self {\n+        match format {\n+            TextSignFormat::Blake3 => \"blake3\",\n+            TextSignFormat::Ed25519 => \"ed25519\",\n+        }\n+    }\n+}\n+\n+\n+impl fmt::Display for TextSignFormat {\n+    \n+\n+    fn fmt(&self,f:&mut fmt::Fromatter<'_>) -> fmt::Result {\n+        write!(f,\"{}\", Into::<&str>::into(*self));\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701845623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,5 +110,16 @@\n \n     fn fmt(&self,f:&mut fmt::Fromatter<'_>) -> fmt::Result {\n         write!(f,\"{}\", Into::<&str>::into(*self));\n     }\n+}\n+\n+\n+impl CmdExector for TextSignOpts {\n+\n+    async fn execute(self) -> anyhow::Result<()> {\n+\n+        let mut reader = get_reader(&self.input)?;\n+        let key = get_content(&self.key);\n+        let sig = process_text_sign(&mut reader,&key,self.format)?;\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701887892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,6 +120,12 @@\n \n         let mut reader = get_reader(&self.input)?;\n         let key = get_content(&self.key);\n         let sig = process_text_sign(&mut reader,&key,self.format)?;\n+\n+        let encoded = URL_SAFE_NO_PAD.encode(sig);\n+\n+        println!(\"{}\",encoded );\n+\n+        Ok(());\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718701963946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,11 +117,11 @@\n impl CmdExector for TextSignOpts {\n \n     async fn execute(self) -> anyhow::Result<()> {\n \n-        let mut reader = get_reader(&self.input)?;\n-        let key = get_content(&self.key);\n-        let sig = process_text_sign(&mut reader,&key,self.format)?;\n+        let mut reader:Box<dyn Read> = get_reader(&self.input)?;\n+        let key:Vec<u8> = get_content(&self.key);\n+        let sig:Vec<u8> = process_text_sign(&mut reader,&key,self.format)?;\n \n         let encoded = URL_SAFE_NO_PAD.encode(sig);\n \n         println!(\"{}\",encoded );\n"
                },
                {
                    "date": 1718701970621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,131 @@\n+use crate::{\n+    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n+    CmdExector,\n+}\n+\n+use super::{verify_file,verify_path};\n+use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n+use clap::Parser;\n+use enum_dispatch::enum_dispatch;\n+use std::{fmt,path::PathBuf,str::FromStr};\n+use tokio::fs;\n+\n+#[derive(Debug,Parser)]\n+#[enum_dispatch(CmdExector)]\n+\n+pub enum TextSubCommand {\n+\n+    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n+    Sign(TextSignOpts),\n+\n+    #[command(about =\"Verify a signature with a public/session key\")]\n+    Verify(TextVerifyOpts),\n+\n+    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n+    Generate(KeyGenerateOpts),\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextSignOpts {\n+\n+\n+    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser = verify_file)]\n+    pub key:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextVerifyOpts {\n+\n+\n+    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser=verify_file)]\n+    pub key:String,\n+\n+    #[arg(long)]\n+    pub sig:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct KeyGenerateOpts {\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+\n+    #[arg(short,long,value_parser=verify_path)]\n+    pub output_path:PathBuf,\n+}\n+\n+#[derive(Debug,Clone,Copy)]\n+pub enum TextSignFormat {\n+\n+        Blake3,\n+        Ed25519,\n+}\n+\n+\n+fn parse_text_sign_format(format:&str) -> Result<TextSignFormat,anyhow::Error>{\n+    format.parse();\n+}\n+\n+\n+impl FromStr for TextSignFormat {\n+\n+    type Err = anyhow::Error;\n+\n+    fn from_str(s:&str) -> Result<Self,Self::Err>{\n+        match s {\n+             \"blake3\"=> Ok(TextSignFormat::Blake3) ,\n+             \"ed25519\"=> Ok(TextSignFormat::Ed25519) ,\n+            _ => Err(anyhow::anyhow!(\"Invalid format\")),\n+        }\n+    }\n+}\n+\n+impl From<TextSignFormat> for &'static str {\n+    fn from(format:TextSignFormat) -> Self {\n+        match format {\n+            TextSignFormat::Blake3 => \"blake3\",\n+            TextSignFormat::Ed25519 => \"ed25519\",\n+        }\n+    }\n+}\n+\n+\n+impl fmt::Display for TextSignFormat {\n+    \n+\n+    fn fmt(&self,f:&mut fmt::Fromatter<'_>) -> fmt::Result {\n+        write!(f,\"{}\", Into::<&str>::into(*self));\n+    }\n+}\n+\n+\n+impl CmdExector for TextSignOpts {\n+\n+    async fn execute(self) -> anyhow::Result<()> {\n+\n+        let mut reader:Box<dyn Read> = get_reader(&self.input)?;\n+        let key:Vec<u8> = get_content(&self.key);\n+        let sig:Vec<u8> = process_text_sign(&mut reader,&key,self.format)?;\n+\n+        let encoded:String = URL_SAFE_NO_PAD.encode(sig);\n+\n+        println!(\"{}\",encoded );\n+\n+        Ok(());\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718703256779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,152 @@\n+use crate::{\n+    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n+    CmdExector,\n+}\n+\n+use super::{verify_file,verify_path};\n+use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n+use clap::Parser;\n+use enum_dispatch::enum_dispatch;\n+use std::{fmt,path::PathBuf,str::FromStr};\n+use tokio::fs;\n+\n+#[derive(Debug,Parser)]\n+#[enum_dispatch(CmdExector)]\n+\n+pub enum TextSubCommand {\n+\n+    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n+    Sign(TextSignOpts),\n+\n+    #[command(about =\"Verify a signature with a public/session key\")]\n+    Verify(TextVerifyOpts),\n+\n+    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n+    Generate(KeyGenerateOpts),\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextSignOpts {\n+\n+\n+    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser = verify_file)]\n+    pub key:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct TextVerifyOpts {\n+\n+\n+    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n+    pub input:String,\n+\n+    #[arg(short,long,value_parser=verify_file)]\n+    pub key:String,\n+\n+    #[arg(long)]\n+    pub sig:String,\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+}\n+\n+\n+#[derive(Debug,Parser)]\n+pub struct KeyGenerateOpts {\n+\n+    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n+    pub format:TextSignFormat,\n+\n+    #[arg(short,long,value_parser=verify_path)]\n+    pub output_path:PathBuf,\n+}\n+\n+#[derive(Debug,Clone,Copy)]\n+pub enum TextSignFormat {\n+\n+        Blake3,\n+        Ed25519,\n+}\n+\n+\n+fn parse_text_sign_format(format:&str) -> Result<TextSignFormat,anyhow::Error>{\n+    format.parse();\n+}\n+\n+\n+impl FromStr for TextSignFormat {\n+\n+    type Err = anyhow::Error;\n+\n+    fn from_str(s:&str) -> Result<Self,Self::Err>{\n+        match s {\n+             \"blake3\"=> Ok(TextSignFormat::Blake3) ,\n+             \"ed25519\"=> Ok(TextSignFormat::Ed25519) ,\n+            _ => Err(anyhow::anyhow!(\"Invalid format\")),\n+        }\n+    }\n+}\n+\n+impl From<TextSignFormat> for &'static str {\n+    fn from(format:TextSignFormat) -> Self {\n+        match format {\n+            TextSignFormat::Blake3 => \"blake3\",\n+            TextSignFormat::Ed25519 => \"ed25519\",\n+        }\n+    }\n+}\n+\n+\n+impl fmt::Display for TextSignFormat {\n+    \n+\n+    fn fmt(&self,f:&mut fmt::Fromatter<'_>) -> fmt::Result {\n+        write!(f,\"{}\", Into::<&str>::into(*self));\n+    }\n+}\n+\n+\n+impl CmdExector for TextSignOpts {\n+\n+    async fn execute(self) -> anyhow::Result<()> {\n+\n+        let mut reader:Box<dyn Read> = get_reader(&self.input)?;\n+        let key:Vec<u8> = get_content(&self.key);\n+        let sig:Vec<u8> = process_text_sign(&mut reader,&key,self.format)?;\n+\n+        let encoded:String = URL_SAFE_NO_PAD.encode(sig);\n+\n+        println!(\"{}\",encoded );\n+\n+        Ok(());\n+    }\n+}\n+\n+\n+\n+impl CmdExector for TextVerifyOpts {\n+    async fn execute(self) -> anyhow::Result<()> {\n+\n+        let mut  reader:Box<dyn Read> = get_reader(&self.input);\n+        let key:Vec<u8> = get_content(&self.key)?;\n+        let decoded:Vec<u8> = URL_SAFE_NO_PAD.decode(&self.sig)?;\n+\n+        let verified:bool = process_text_verify(&mut reader,&key,&decoded,self.format)?;\n+\n+        if verified {\n+            println!(\"Signature verified\");\n+        }else {\n+            println!(\"Signature not verified\");\n+        }\n+\n+        Ok(());\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718703412905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,266 +149,14 @@\n \n         Ok(());\n     }\n }\n-use crate::{\n-    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n-    CmdExector,\n-}\n \n-use super::{verify_file,verify_path};\n-use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n-use clap::Parser;\n-use enum_dispatch::enum_dispatch;\n-use std::{fmt,path::PathBuf,str::FromStr};\n-use tokio::fs;\n+impl CmdExector for KeyGenerateOpts {\n \n-#[derive(Debug,Parser)]\n-#[enum_dispatch(CmdExector)]\n+    async fn execute(Self)-> anyhow::Result<()> {\n \n-pub enum TextSubCommand {\n+        let key:std::collectons::HashMap<&str,Vec<u8>> = process_text_key_generate(self.format)?;\n \n-    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n-    Sign(TextSignOpts),\n-\n-    #[command(about =\"Verify a signature with a public/session key\")]\n-    Verify(TextVerifyOpts),\n-\n-    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n-    Generate(KeyGenerateOpts),\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct TextSignOpts {\n-\n-\n-    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n-    pub input:String,\n-\n-    #[arg(short,long,value_parser = verify_file)]\n-    pub key:String,\n-\n-    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct TextVerifyOpts {\n-\n-\n-    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n-    pub input:String,\n-\n-    #[arg(short,long,value_parser=verify_file)]\n-    pub key:String,\n-\n-    #[arg(long)]\n-    pub sig:String,\n-\n-    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct KeyGenerateOpts {\n-\n-    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-\n-    #[arg(short,long,value_parser=verify_path)]\n-    pub output_path:PathBuf,\n-}\n-\n-#[derive(Debug,Clone,Copy)]\n-pub enum TextSignFormat {\n-\n-        Blake3,\n-        Ed25519,\n-}\n-\n-\n-fn parse_text_sign_format(format:&str) -> Result<TextSignFormat,anyhow::Error>{\n-    format.parse();\n-}\n-\n-\n-impl FromStr for TextSignFormat {\n-\n-    type Err = anyhow::Error;\n-\n-    fn from_str(s:&str) -> Result<Self,Self::Err>{\n-        match s {\n-             \"blake3\"=> Ok(TextSignFormat::Blake3) ,\n-             \"ed25519\"=> Ok(TextSignFormat::Ed25519) ,\n-            _ => Err(anyhow::anyhow!(\"Invalid format\")),\n-        }\n+        \n     }\n-}\n-\n-impl From<TextSignFormat> for &'static str {\n-    fn from(format:TextSignFormat) -> Self {\n-        match format {\n-            TextSignFormat::Blake3 => \"blake3\",\n-            TextSignFormat::Ed25519 => \"ed25519\",\n-        }\n-    }\n-}\n-\n-\n-impl fmt::Display for TextSignFormat {\n-    \n-\n-    fn fmt(&self,f:&mut fmt::Fromatter<'_>) -> fmt::Result {\n-        write!(f,\"{}\", Into::<&str>::into(*self));\n-    }\n-}\n-\n-\n-impl CmdExector for TextSignOpts {\n-\n-    async fn execute(self) -> anyhow::Result<()> {\n-\n-        let mut reader:Box<dyn Read> = get_reader(&self.input)?;\n-        let key:Vec<u8> = get_content(&self.key);\n-        let sig:Vec<u8> = process_text_sign(&mut reader,&key,self.format)?;\n-\n-        let encoded:String = URL_SAFE_NO_PAD.encode(sig);\n-\n-        println!(\"{}\",encoded );\n-\n-        Ok(());\n-    }\n-}\n-use crate::{\n-    get_content,get_reader,process_text_key_generate,process_text_sign,process_text_verify,\n-    CmdExector,\n-}\n-\n-use super::{verify_file,verify_path};\n-use base64::{engine::general_purpose::URL_SAFE_NO_PAD,Engine};\n-use clap::Parser;\n-use enum_dispatch::enum_dispatch;\n-use std::{fmt,path::PathBuf,str::FromStr};\n-use tokio::fs;\n-\n-#[derive(Debug,Parser)]\n-#[enum_dispatch(CmdExector)]\n-\n-pub enum TextSubCommand {\n-\n-    #[command(about=\"Sign a text with a private/session key and return a signature\")]\n-    Sign(TextSignOpts),\n-\n-    #[command(about =\"Verify a signature with a public/session key\")]\n-    Verify(TextVerifyOpts),\n-\n-    #[command(about=\"Generate a random blake3 key or ed25519 key pair\")]\n-    Generate(KeyGenerateOpts),\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct TextSignOpts {\n-\n-\n-    #[arg(short, long,value_parser = verify_file,default_value=\"-\")]\n-    pub input:String,\n-\n-    #[arg(short,long,value_parser = verify_file)]\n-    pub key:String,\n-\n-    #[arg(long,default_value=\"blake3\",value_parser = parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct TextVerifyOpts {\n-\n-\n-    #[arg(short,long,value_parser=verify_file,default_value=\"-\")]\n-    pub input:String,\n-\n-    #[arg(short,long,value_parser=verify_file)]\n-    pub key:String,\n-\n-    #[arg(long)]\n-    pub sig:String,\n-\n-    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-}\n-\n-\n-#[derive(Debug,Parser)]\n-pub struct KeyGenerateOpts {\n-\n-    #[arg(long,default_value=\"blake3\",value_parser=parse_text_sign_format)]\n-    pub format:TextSignFormat,\n-\n-    #[arg(short,long,value_parser=verify_path)]\n-    pub output_path:PathBuf,\n-}\n-\n-#[derive(Debug,Clone,Copy)]\n-pub enum TextSignFormat {\n-\n-        Blake3,\n-        Ed25519,\n-}\n-\n-\n-fn parse_text_sign_format(format:&str) -> Result<TextSignFormat,anyhow::Error>{\n-    format.parse();\n-}\n-\n-\n-impl FromStr for TextSignFormat {\n-\n-    type Err = anyhow::Error;\n-\n-    fn from_str(s:&str) -> Result<Self,Self::Err>{\n-        match s {\n-             \"blake3\"=> Ok(TextSignFormat::Blake3) ,\n-             \"ed25519\"=> Ok(TextSignFormat::Ed25519) ,\n-            _ => Err(anyhow::anyhow!(\"Invalid format\")),\n-        }\n-    }\n-}\n-\n-impl From<TextSignFormat> for &'static str {\n-    fn from(format:TextSignFormat) -> Self {\n-        match format {\n-            TextSignFormat::Blake3 => \"blake3\",\n-            TextSignFormat::Ed25519 => \"ed25519\",\n-        }\n-    }\n-}\n-\n-\n-impl fmt::Display for TextSignFormat {\n-    \n-\n-    fn fmt(&self,f:&mut fmt::Fromatter<'_>) -> fmt::Result {\n-        write!(f,\"{}\", Into::<&str>::into(*self));\n-    }\n-}\n-\n-\n-impl CmdExector for TextSignOpts {\n-\n-    async fn execute(self) -> anyhow::Result<()> {\n-\n-        let mut reader:Box<dyn Read> = get_reader(&self.input)?;\n-        let key:Vec<u8> = get_content(&self.key);\n-        let sig:Vec<u8> = process_text_sign(&mut reader,&key,self.format)?;\n-\n-        let encoded = URL_SAFE_NO_PAD.encode(sig);\n-\n-        println!(\"{}\",encoded );\n-\n-        Ok(());\n-    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718703473985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,7 +156,9 @@\n     async fn execute(Self)-> anyhow::Result<()> {\n \n         let key:std::collectons::HashMap<&str,Vec<u8>> = process_text_key_generate(self.format)?;\n \n-        \n+        for(k,v) in key {\n+            fs::write(self.output_path.join(k),v).await?;\n+        }\n     }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1718703481060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,6 +159,8 @@\n \n         for(k,v) in key {\n             fs::write(self.output_path.join(k),v).await?;\n         }\n+\n+        Ok(())\n     }\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1718697204612,
            "name": "Commit-0",
            "content": "use crate::{\n    get_content,get_reader,\n}"
        }
    ]
}