{
    "sourceFile": "src/matrix.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 66,
            "patches": [
                {
                    "date": 1719390122169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1719391573010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,1 @@\n-use crate::{dot_product,Vector};\n+ \n"
                },
                {
                    "date": 1719484351792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,2 @@\n- \n+use crate::{dot_product,Vector};\n+use anyhow::{anyhow,Result};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567463440,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,2 +1,8 @@\n use crate::{dot_product,Vector};\n-use anyhow::{anyhow,Result};\n\\ No newline at end of file\n+use anyhow::{anyhow,Result};\n+use std::{\n+    fmt,\n+    ops::{Add,AddAssign,Mul},\n+    sync::mpsc,\n+    thread,\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567481351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,5 +4,8 @@\n     fmt,\n     ops::{Add,AddAssign,Mul},\n     sync::mpsc,\n     thread,\n-};\n\\ No newline at end of file\n+};\n+\n+\n+cont num_threads:usize = 4;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567486989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,5 +7,5 @@\n     thread,\n };\n \n \n-cont num_threads:usize = 4;\n\\ No newline at end of file\n+const NUM_THREADS:usize = 4;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567524262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,5 +7,11 @@\n     thread,\n };\n \n \n-const NUM_THREADS:usize = 4;\n\\ No newline at end of file\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567630826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,5 +13,12 @@\n pub struct Matrix<T> {\n     data:Vec<T>,\n     row:usize,\n     col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567744692,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,5 +20,12 @@\n pub struct MsgInput<T> {\n     idx: usize,\n     row: Vector<T>,\n     col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567789596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,5 +27,12 @@\n pub struct MsgOutput<T> {\n \n     idx: usize,\n     value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719567951127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,5 +34,12 @@\n pub struct Msg<T> {\n \n     input: MsgInput<T>,\n     sender: oneshot::Sender<MsgOutput<T>>,\n-}\n\\ No newline at end of file\n+}\n+\n+\n+pub fn multiply<T>(a:&matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    \n+}\n"
                },
                {
                    "date": 1719567998495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,8 @@\n use crate::{dot_product,Vector};\n use anyhow::{anyhow,Result};\n use std::{\n-    fmt,\n-    ops::{Add,AddAssign,Mul},\n-    sync::mpsc,\n-    thread,\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n };\n \n \n const NUM_THREADS:usize = 4;\n@@ -40,6 +37,8 @@\n \n pub fn multiply<T>(a:&matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n {\n-    \n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\");\n+    }\n }\n"
                },
                {
                    "date": 1719568119418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,11 +34,19 @@\n     sender: oneshot::Sender<MsgOutput<T>>,\n }\n \n \n-pub fn multiply<T>(a:&matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n {\n     if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\");\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n     }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+\n+    })\n+    .collect::<Vec<_>>();\n+\n+\n }\n"
                },
                {
                    "date": 1719568171403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,10 @@\n     }\n \n \n     let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+            \n     })\n     .collect::<Vec<_>>();\n \n \n"
                },
                {
                    "date": 1719568186724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,12 @@\n \n \n     let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n             let (tx,rx) = mpsc::channel::<Msg<T>>();\n-            \n+\n+            thread::spawn(move ||{\n+                \n+            });\n     })\n     .collect::<Vec<_>>();\n \n \n"
                },
                {
                    "date": 1719568291811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,11 @@\n     let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n             let (tx,rx) = mpsc::channel::<Msg<T>>();\n \n             thread::spawn(move ||{\n-                \n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                }\n             });\n     })\n     .collect::<Vec<_>>();\n \n"
                },
                {
                    "date": 1719568471815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,14 @@\n \n             thread::spawn(move ||{\n                 for msg in rx {\n                     let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n                 }\n             });\n     })\n     .collect::<Vec<_>>();\n"
                },
                {
                    "date": 1719568500153,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,9 @@\n                     }){\n                         eprint!(\"Send error:{:?}\",e);\n                     }\n                 }\n+                Ok::<_,anyhow::Error>(())\n             });\n     })\n     .collect::<Vec<_>>();\n \n"
                },
                {
                    "date": 1719568538748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,12 @@\n                     }\n                 }\n                 Ok::<_,anyhow::Error>(())\n             });\n+            tx\n     })\n     .collect::<Vec<_>>();\n \n \n+    \n+\n }\n"
                },
                {
                    "date": 1719568621874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,7 +62,10 @@\n     })\n     .collect::<Vec<_>>();\n \n \n+    for rx in receivers {\n+        \n+    }\n     \n \n }\n"
                },
                {
                    "date": 1719568649215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,8 +63,9 @@\n     .collect::<Vec<_>>();\n \n \n     for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n         \n     }\n     \n \n"
                },
                {
                    "date": 1719568659264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,72 @@\n+use crate::{dot_product,Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+    \n+\n+}\n"
                },
                {
                    "date": 1719568764535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,84 +61,17 @@\n             tx\n     })\n     .collect::<Vec<_>>();\n \n+    let matrix_len:usize = a.row * b.col;\n+    \n \n     for rx in receivers {\n         let output:MsgOutput<T> = rx.recv()?;\n         data[output.idx] = output.value;\n     }\n-    \n \n-}\n-use crate::{dot_product,Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n \n \n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        \n-    }\n     \n \n }\n"
                },
                {
                    "date": 1719569277421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,8 +62,10 @@\n     })\n     .collect::<Vec<_>>();\n \n     let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n     \n \n     for rx in receivers {\n         let output:MsgOutput<T> = rx.recv()?;\n"
                },
                {
                    "date": 1719569388566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-use crate::{dot_product,Vector};\n+use crate::{dot_product, vector::Vector, Vector};\n use anyhow::{anyhow,Result};\n use std::{\n     any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n };\n@@ -64,10 +64,16 @@\n \n     let matrix_len:usize = a.row * b.col;\n     let mut data:Vec<T> = vec![T::default();matrix_len];\n     let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-    \n \n+    for i in 0..a.row{\n+        for j in b.col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            \n+        }\n+    }\n+\n     for rx in receivers {\n         let output:MsgOutput<T> = rx.recv()?;\n         data[output.idx] = output.value;\n     }\n"
                },
                {
                    "date": 1719569451248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,14 @@\n \n     for i in 0..a.row{\n         for j in b.col{\n             let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            \n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+        \n         }\n     }\n \n     for rx in receivers {\n"
                },
                {
                    "date": 1719569460870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,16 +66,16 @@\n     let mut data:Vec<T> = vec![T::default();matrix_len];\n     let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n \n     for i in 0..a.row{\n-        for j in b.col{\n+        for j in b..col{\n             let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n             let col_data:Vec<T> = b.data[j..]\n             .iter()\n             .step_by(b.col)\n             .copied()\n             .collect::<Vec<_>>();\n-        \n+\n         }\n     }\n \n     for rx in receivers {\n"
                },
                {
                    "date": 1719569511717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,8 +74,10 @@\n             .step_by(b.col)\n             .copied()\n             .collect::<Vec<_>>();\n \n+            let col:Vector<T> = Vector::new(col_data);\n+            \n         }\n     }\n \n     for rx in receivers {\n"
                },
                {
                    "date": 1719569542697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,9 @@\n             .copied()\n             .collect::<Vec<_>>();\n \n             let col:Vector<T> = Vector::new(col_data);\n-            \n+            let idx:usize =  i * b.col + j;\n         }\n     }\n \n     for rx in receivers {\n"
                },
                {
                    "date": 1719569725700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,8 +76,10 @@\n             .collect::<Vec<_>>();\n \n             let col:Vector<T> = Vector::new(col_data);\n             let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n         }\n     }\n \n     for rx in receivers {\n"
                },
                {
                    "date": 1719569746021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,96 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+            \n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+\n+\n+    \n+\n+}\n"
                },
                {
                    "date": 1719569891988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,103 +79,17 @@\n             let idx:usize =  i * b.col + j;\n             let input:MsgInput<T> = MsgInput::new(idx, row, col);\n             let (tx,rx) = oneshot::channel();\n             let msg:Msg<T> = Msg::new(input, tx);\n-            \n-        }\n-    }\n \n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n \n+                eprint!(\"Send error: {:?}\", e);\n+            }\n \n \n-    \n+            receivers.push(rx);\n \n-}\n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n         }\n     }\n \n     for rx in receivers {\n"
                },
                {
                    "date": 1719569926651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,13 @@\n         let output:MsgOutput<T> = rx.recv()?;\n         data[output.idx] = output.value;\n     }\n \n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n \n-\n     \n \n }\n"
                },
                {
                    "date": 1719569935891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,4 +105,7 @@\n \n     \n \n }\n+\n+\n+\n"
                },
                {
                    "date": 1719826729984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,5 +107,13 @@\n \n }\n \n \n-\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n"
                },
                {
                    "date": 1719826748930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,4 +116,13 @@\n             col,\n         }\n     }\n }\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>{\n+    \n+}\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719826768079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,12 @@\n \n \n \n \n-impl <T> fmt::Display for Matrix<T>{\n-    \n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+\n }\n     \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719826780949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,130 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+\n+}\n+    \n"
                },
                {
                    "date": 1719826794025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,142 +120,5 @@\n \n \n \n \n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-\n-}\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-\n-}\n-    \n-}\n\\ No newline at end of file\n+ \n\\ No newline at end of file\n"
                },
                {
                    "date": 1719826833398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,5 +120,14 @@\n \n \n \n \n- \n\\ No newline at end of file\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&Self,f:&mut fmt::Formatter) -> fmt::Result {\n+        \n+    }\n+}\n+    \n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719826872751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,9 +125,9 @@\n where \n     T:fmt::Display,\n {\n     fn fmt(&Self,f:&mut fmt::Formatter) -> fmt::Result {\n-        \n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n     }\n }\n     \n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719827210805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,6 +128,7 @@\n     fn fmt(&Self,f:&mut fmt::Formatter) -> fmt::Result {\n          write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n     }\n }\n+\n+\n\\ No newline at end of file\n     \n-}\n"
                },
                {
                    "date": 1719827222261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,134 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+    \n"
                },
                {
                    "date": 1719827235801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,134 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+    \n"
                },
                {
                    "date": 1719827359712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,273 +130,14 @@\n     }\n }\n \n \n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n         Self {\n-            data:data.into(),\n-            row,\n-            col,\n+            idx,row,col\n         }\n     }\n }\n \n \n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n     \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&Self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n\\ No newline at end of file\n-\n-\n-    \n"
                },
                {
                    "date": 1719827448721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,149 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+    \n+    }\n+}\n+\n+\n+    \n"
                },
                {
                    "date": 1719828026780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,149 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+    \n"
                },
                {
                    "date": 1719828110675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,158 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+    }\n+\n+\n+    \n"
                },
                {
                    "date": 1719828194506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,449 +151,11 @@\n     T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n     {\n         type Output = Self;\n         \n-    }\n-\n-\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n         }\n     }\n \n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n \n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n     \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-    \n-    }\n-}\n-\n-\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-\n-    \n"
                },
                {
                    "date": 1719828258497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,8 +154,21 @@\n         \n         fn mul(self,rhs:Self) -> Self::Output{\n             multiply(&self,&rhs).expect(\"Matrix multiply error\");\n         }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+        \n     }\n+}\n \n \n     \n"
                },
                {
                    "date": 1719828321182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,8 +165,11 @@\n \n \n     #[test]\n     fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n         \n     }\n }\n \n"
                },
                {
                    "date": 1719828345583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,17 +160,22 @@\n #[cfg(test)]\n mod tests {\n \n \n+    use anyhow::Ok;\n+\n     use super::*;\n \n \n     #[test]\n     fn test_matrix_multiply()-> Result<()> {\n \n         let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n         let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-        \n+\n+        let c:Matrix<i32> = a * b;\n+\n+        Ok(())\n     }\n }\n \n \n"
                },
                {
                    "date": 1719828493589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,8 +173,13 @@\n         let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n \n         let c:Matrix<i32> = a * b;\n \n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n         Ok(())\n     }\n }\n \n"
                },
                {
                    "date": 1719828571602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,192 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow,Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    \n+}\n+    \n"
                },
                {
                    "date": 1719828578393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,193 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow, Ok, Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+\n+    Ok(())\n+}\n+    \n"
                },
                {
                    "date": 1719828612823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,194 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow, Ok, Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n+    \n+    Ok(())\n+}\n+    \n"
                },
                {
                    "date": 1719828705490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,580 +187,11 @@\n fn test_matrix_display()-> Result<()> {\n \n     let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n     let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n-    \n-    Ok(())\n-}\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow, Ok, Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n+    let c:Matrix<i32> = a * b;\n \n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_matrix_display()-> Result<()> {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-\n+    assert_eq!(c.data,vec![7,10,15,22]);\n+    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n     Ok(())\n }\n     \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_matrix_display()-> Result<()> {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-    \n-}\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow,Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-\n-    \n"
                },
                {
                    "date": 1719828805663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,5 +193,14 @@\n     assert_eq!(c.data,vec![7,10,15,22]);\n     assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n     Ok(())\n }\n+\n+\n+#[test]\n+fn test_a_can_not_multiply_b() {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n     \n+}\n+    \n"
                },
                {
                    "date": 1719828820416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,7 +200,9 @@\n fn test_a_can_not_multiply_b() {\n \n     let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n     let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+\n+    let c:Matrix<i32> = a * b;\n     \n }\n     \n"
                },
                {
                    "date": 1719828826500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,209 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow, Ok, Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n+    let c:Matrix<i32> = a * b;\n+\n+    assert_eq!(c.data,vec![7,10,15,22]);\n+    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n+    Ok(())\n+}\n+\n+\n+#[test]\n+fn test_a_can_not_multiply_b() {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+\n+    let c:Matrix<i32> = a * b;\n+\n+    Ok(())\n+}\n+    \n"
                },
                {
                    "date": 1719828887770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,210 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow, Ok, Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n+    let c:Matrix<i32> = a * b;\n+\n+    assert_eq!(c.data,vec![7,10,15,22]);\n+    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n+    Ok(())\n+}\n+\n+\n+#[test]\n+fn test_a_can_not_multiply_b() {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+\n+    let c:Result<Matrix<i32>,Error> = multiply(&a, &b);\n+\n+\n+    \n+}\n+    \n"
                },
                {
                    "date": 1719828977794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,427 +201,10 @@\n \n     let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n     let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n \n-    let c:Result<Matrix<i32>,Error> = multiply(&a, &b);\n+    let c: std::result::Result<Matrix<i32>,anyhow:Error>:std::result::Result<Matrix<i32>,anyhow:Error> = multiply(&a, &b);\n \n \n     \n }\n     \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow, Ok, Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_matrix_display()-> Result<()> {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n-    let c:Matrix<i32> = a * b;\n-\n-    assert_eq!(c.data,vec![7,10,15,22]);\n-    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n-    Ok(())\n-}\n-\n-\n-#[test]\n-fn test_a_can_not_multiply_b() {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-\n-    let c:Matrix<i32> = a * b;\n-\n-    Ok(())\n-}\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow, Ok, Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_matrix_display()-> Result<()> {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n-    let c:Matrix<i32> = a * b;\n-\n-    assert_eq!(c.data,vec![7,10,15,22]);\n-    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n-    Ok(())\n-}\n-\n-\n-#[test]\n-fn test_a_can_not_multiply_b() {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-\n-    let c:Matrix<i32> = a * b;\n-    \n-}\n-    \n"
                },
                {
                    "date": 1719828997006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,8 +203,10 @@\n     let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n \n     let c: std::result::Result<Matrix<i32>,anyhow:Error>:std::result::Result<Matrix<i32>,anyhow:Error> = multiply(&a, &b);\n \n+    assert!(c.is_err());\n \n+\n     \n }\n     \n"
                },
                {
                    "date": 1719829051107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,217 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow, Ok, Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n+    let c:Matrix<i32> = a * b;\n+\n+    assert_eq!(c.data,vec![7,10,15,22]);\n+    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n+    Ok(())\n+}\n+\n+\n+#[test]\n+fn test_a_can_not_multiply_b() {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+\n+    let c: std::result::Result<Matrix<i32>,anyhow:Error>:std::result::Result<Matrix<i32>,anyhow:Error> = multiply(&a, &b);\n+\n+    assert!(c.is_err());\n+    \n+}\n+\n+\n+#[test]\n+#[should_panic]\n+fn test_a_can_not_multiply_b_panic() {\n+    \n+}\n+    \n"
                },
                {
                    "date": 1719829148698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,220 @@\n+use crate::{dot_product, vector::Vector, Vector};\n+use anyhow::{anyhow, Ok, Result};\n+use std::{\n+    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n+};\n+\n+\n+const NUM_THREADS:usize = 4;\n+\n+pub struct Matrix<T> {\n+    data:Vec<T>,\n+    row:usize,\n+    col: usize,\n+}\n+\n+\n+pub struct MsgInput<T> {\n+    idx: usize,\n+    row: Vector<T>,\n+    col: Vector<T>,\n+}\n+\n+\n+pub struct MsgOutput<T> {\n+\n+    idx: usize,\n+    value: T,\n+}\n+\n+\n+pub struct Msg<T> {\n+\n+    input: MsgInput<T>,\n+    sender: oneshot::Sender<MsgOutput<T>>,\n+}\n+\n+\n+pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n+where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n+{\n+    if a.col != b.row {\n+        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n+    }\n+\n+\n+    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n+            let (tx,rx) = mpsc::channel::<Msg<T>>();\n+\n+            thread::spawn(move ||{\n+                for msg in rx {\n+                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n+                    if let Err(e) = msg.sender.send(MsgOutput {\n+                        idx:msg.input.idx,\n+                        value,\n+                    }){\n+                        eprint!(\"Send error:{:?}\",e);\n+                    }\n+                }\n+                Ok::<_,anyhow::Error>(())\n+            });\n+            tx\n+    })\n+    .collect::<Vec<_>>();\n+\n+    let matrix_len:usize = a.row * b.col;\n+    let mut data:Vec<T> = vec![T::default();matrix_len];\n+    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n+\n+    for i in 0..a.row{\n+        for j in b..col{\n+            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n+            let col_data:Vec<T> = b.data[j..]\n+            .iter()\n+            .step_by(b.col)\n+            .copied()\n+            .collect::<Vec<_>>();\n+\n+            let col:Vector<T> = Vector::new(col_data);\n+            let idx:usize =  i * b.col + j;\n+            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n+            let (tx,rx) = oneshot::channel();\n+            let msg:Msg<T> = Msg::new(input, tx);\n+\n+            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n+\n+                eprint!(\"Send error: {:?}\", e);\n+            }\n+\n+\n+            receivers.push(rx);\n+\n+        }\n+    }\n+\n+    for rx in receivers {\n+        let output:MsgOutput<T> = rx.recv()?;\n+        data[output.idx] = output.value;\n+    }\n+\n+  Ok(Matrix{\n+    data,\n+    row: a.row,\n+    col: b.col,\n+  })\n+\n+    \n+\n+}\n+\n+\n+impl<T:fmt::Debug> Matrix<T>{\n+    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n+        Self {\n+            data:data.into(),\n+            row,\n+            col,\n+        }\n+    }\n+}\n+\n+\n+\n+\n+impl <T> fmt::Display for Matrix<T>\n+where \n+    T:fmt::Display,\n+{\n+    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n+         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n+    }\n+}\n+\n+\n+impl<T> MsgInput<T> {\n+    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n+        Self {\n+            idx,row,col\n+        }\n+    }\n+}\n+\n+impl<T> Msg<T>   {\n+    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n+        Self{input,sender}\n+    }\n+}\n+\n+\n+impl<T> Mul for Matrix<T> \n+where  \n+    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n+    {\n+        type Output = Self;\n+        \n+        fn mul(self,rhs:Self) -> Self::Output{\n+            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n+        }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+\n+    use anyhow::Ok;\n+\n+    use super::*;\n+\n+\n+    #[test]\n+    fn test_matrix_multiply()-> Result<()> {\n+\n+        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n+        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n+\n+        let c:Matrix<i32> = a * b;\n+\n+        assert!(c.col,2);\n+        assert!(c.row,2);\n+        assert!(c.data,vec![22,28,49,54]);\n+        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n+\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_matrix_display()-> Result<()> {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n+    let c:Matrix<i32> = a * b;\n+\n+    assert_eq!(c.data,vec![7,10,15,22]);\n+    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n+    Ok(())\n+}\n+\n+\n+#[test]\n+fn test_a_can_not_multiply_b() {\n+\n+    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+\n+    let c: std::result::Result<Matrix<i32>,anyhow:Error>:std::result::Result<Matrix<i32>,anyhow:Error> = multiply(&a, &b);\n+\n+    assert!(c.is_err());\n+    \n+}\n+\n+\n+#[test]\n+#[should_panic]\n+fn test_a_can_not_multiply_b_panic() {\n+    \n+    let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6], 2, 3);\n+    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n+    let _c:Matrix<i32> = a * b;\n+}\n+    \n"
                },
                {
                    "date": 1719829158845,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -216,5 +216,5 @@\n     let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6], 2, 3);\n     let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n     let _c:Matrix<i32> = a * b;\n }\n-    \n+\n"
                },
                {
                    "date": 1719829189585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,10 +180,10 @@\n         assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n \n         Ok(())\n     }\n-}\n \n+\n #[test]\n fn test_matrix_display()-> Result<()> {\n \n     let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n@@ -217,433 +217,6 @@\n     let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n     let _c:Matrix<i32> = a * b;\n }\n \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow, Ok, Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n }\n \n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_matrix_display()-> Result<()> {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n-    let c:Matrix<i32> = a * b;\n-\n-    assert_eq!(c.data,vec![7,10,15,22]);\n-    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n-    Ok(())\n-}\n-\n-\n-#[test]\n-fn test_a_can_not_multiply_b() {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-\n-    let c: std::result::Result<Matrix<i32>,anyhow:Error>:std::result::Result<Matrix<i32>,anyhow:Error> = multiply(&a, &b);\n-\n-    assert!(c.is_err());\n-    \n-}\n-\n-\n-#[test]\n-#[should_panic]\n-fn test_a_can_not_multiply_b_panic() {\n-    \n-}\n-    \n-use crate::{dot_product, vector::Vector, Vector};\n-use anyhow::{anyhow, Ok, Result};\n-use std::{\n-    any, fmt, ops::{Add,AddAssign,Mul}, process::Output, sync::mpsc, thread\n-};\n-\n-\n-const NUM_THREADS:usize = 4;\n-\n-pub struct Matrix<T> {\n-    data:Vec<T>,\n-    row:usize,\n-    col: usize,\n-}\n-\n-\n-pub struct MsgInput<T> {\n-    idx: usize,\n-    row: Vector<T>,\n-    col: Vector<T>,\n-}\n-\n-\n-pub struct MsgOutput<T> {\n-\n-    idx: usize,\n-    value: T,\n-}\n-\n-\n-pub struct Msg<T> {\n-\n-    input: MsgInput<T>,\n-    sender: oneshot::Sender<MsgOutput<T>>,\n-}\n-\n-\n-pub fn multiply<T>(a:&Matrix<T>,b:&Matrix<T>) -> Result<Matrix<T>> \n-where T:Copy + Default + Add<Output = T> + AddAssign + Mul<Output = T> + Send +'static,\n-{\n-    if a.col != b.row {\n-        return Err(anyhow!(\"Matrix multiply error: a.col != b.row\"));\n-    }\n-\n-\n-    let senders:Vec<mpsc::Sender<Msg<T>>> = (0..NUM_THREADS).map(|_| {\n-            let (tx,rx) = mpsc::channel::<Msg<T>>();\n-\n-            thread::spawn(move ||{\n-                for msg in rx {\n-                    let  value:T = dot_product(msg.input.row,msg.input.col)?;  \n-                    if let Err(e) = msg.sender.send(MsgOutput {\n-                        idx:msg.input.idx,\n-                        value,\n-                    }){\n-                        eprint!(\"Send error:{:?}\",e);\n-                    }\n-                }\n-                Ok::<_,anyhow::Error>(())\n-            });\n-            tx\n-    })\n-    .collect::<Vec<_>>();\n-\n-    let matrix_len:usize = a.row * b.col;\n-    let mut data:Vec<T> = vec![T::default();matrix_len];\n-    let mut receivers:Vec<oneshot::Receiver<MsgOutput<T>>> = Vec::with_capacity(matrix_len);\n-\n-    for i in 0..a.row{\n-        for j in b..col{\n-            let row:Vector<T> = Vector::new(&a.data[i*a.col..(i+1) * a.col]);\n-            let col_data:Vec<T> = b.data[j..]\n-            .iter()\n-            .step_by(b.col)\n-            .copied()\n-            .collect::<Vec<_>>();\n-\n-            let col:Vector<T> = Vector::new(col_data);\n-            let idx:usize =  i * b.col + j;\n-            let input:MsgInput<T> = MsgInput::new(idx, row, col);\n-            let (tx,rx) = oneshot::channel();\n-            let msg:Msg<T> = Msg::new(input, tx);\n-\n-            if let Err(e) = senders[id% NUM_THREADS].send(msg) {\n-\n-                eprint!(\"Send error: {:?}\", e);\n-            }\n-\n-\n-            receivers.push(rx);\n-\n-        }\n-    }\n-\n-    for rx in receivers {\n-        let output:MsgOutput<T> = rx.recv()?;\n-        data[output.idx] = output.value;\n-    }\n-\n-  Ok(Matrix{\n-    data,\n-    row: a.row,\n-    col: b.col,\n-  })\n-\n-    \n-\n-}\n-\n-\n-impl<T:fmt::Debug> Matrix<T>{\n-    pub fn new(data:impl Into<Vec<T>>,row:usize,col:usize) -> Self{\n-        Self {\n-            data:data.into(),\n-            row,\n-            col,\n-        }\n-    }\n-}\n-\n-\n-\n-\n-impl <T> fmt::Display for Matrix<T>\n-where \n-    T:fmt::Display,\n-{\n-    fn fmt(&self,f:&mut fmt::Formatter) -> fmt::Result {\n-         write!(f,\"Matrix(row ={},col ={},{})\",self.row,self.col,self);\n-    }\n-}\n-\n-\n-impl<T> MsgInput<T> {\n-    pub fn new(idx:usize,row:Vector<T>,col:Vector<T>) -> Self{\n-        Self {\n-            idx,row,col\n-        }\n-    }\n-}\n-\n-impl<T> Msg<T>   {\n-    pub fn new(input:MsgInput<T>,sender:oneshot::Sender<MsgOutput<T>>)-> Self{\n-        Self{input,sender}\n-    }\n-}\n-\n-\n-impl<T> Mul for Matrix<T> \n-where  \n-    T:Copy + Default + Add<Output=T> + AddAssign + Mul<Output=T> + Send + 'static,\n-    {\n-        type Output = Self;\n-        \n-        fn mul(self,rhs:Self) -> Self::Output{\n-            multiply(&self,&rhs).expect(\"Matrix multiply error\");\n-        }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-\n-    use anyhow::Ok;\n-\n-    use super::*;\n-\n-\n-    #[test]\n-    fn test_matrix_multiply()-> Result<()> {\n-\n-        let a:Matrix<i32> = Matrix::new([1,2,3,4,5,6],2,3);\n-        let b:Matrix<i32> = Matrix::new([1,2,3,4,5,6],3,2);\n-\n-        let c:Matrix<i32> = a * b;\n-\n-        assert!(c.col,2);\n-        assert!(c.row,2);\n-        assert!(c.data,vec![22,28,49,54]);\n-        assert_eq!(format!(\"{:?}\",c),\"Matrix(row=2,col=2,{22 28, 49 64\");\n-\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_matrix_display()-> Result<()> {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4], 2, 2);\n-    let c:Matrix<i32> = a * b;\n-\n-    assert_eq!(c.data,vec![7,10,15,22]);\n-    assert_eq!(format!(\"{}\",c),\"{7 10, 15 22}\");\n-    Ok(())\n-}\n-\n-\n-#[test]\n-fn test_a_can_not_multiply_b() {\n-\n-    let a:Matrix<i32> = Matrix::new([1,2,3,4],2,3);\n-    let b:Matrix<i32> = Matrix::new([1,2,3,4],2,2);\n-\n-    let c: std::result::Result<Matrix<i32>,anyhow:Error>:std::result::Result<Matrix<i32>,anyhow:Error> = multiply(&a, &b);\n-\n-    assert!(c.is_err());\n-\n-\n-    \n-}\n-    \n"
                }
            ],
            "date": 1719390122169,
            "name": "Commit-0",
            "content": "use crate::{dot_product,Vector};\n"
        }
    ]
}